# Partie 3: Refactoring stratégique avec JPacman

## Question 1
Quelle est votre stratégie pour planifier ce refactoring ?


Pour planifier l'ajout de la fonctionnalité "Extra Lives" dans JPacman, j'adopte une approche méthodologique en quatre phases distinctes qui privilégie l'incrémentalité et la maîtrise du risque. Ma stratégie s'inspire du principe "Most Valuable First", où chaque refactoring débloque de la valeur pour les étapes suivantes tout en minimisant l'impact sur le code existant.

**Phase 1 - Analyse du système actuel** : Avant toute modification, je commence par comprendre en profondeur comment fonctionne actuellement la gestion de la mort du joueur. L'analyse révèle que dans `Player.java`, un simple attribut booléen `alive` détermine l'état du joueur (ligne 36). Lors d'une collision avec un fantôme, la méthode `setAlive(false)` est appelée directement dans `DefaultPlayerInteractionMap.java` (ligne 52), ce qui déclenche immédiatement le game over. La méthode `isAnyPlayerAlive()` de `Level.java` (ligne 266) vérifie ensuite s'il reste des joueurs vivants et notifie les observateurs via `updateObservers()` qui appelle `levelLost()`. Cette architecture actuelle ne prévoit aucun mécanisme pour gérer plusieurs vies, tout est binaire : vivant ou mort.

**Phase 2 - Planification des refactorings prioritaires** : Fort de cette compréhension, je planifie une séquence de cinq refactorings dans un ordre stratégique. Le premier consiste à ajouter un attribut `remainingLives` (initialisé à 3) avec ses getters/setters dans `Player.java` - c'est le fondement sans risque qui ne casse rien. Le deuxième refactoring extrait une nouvelle méthode `loseLife()` qui décrémente les vies et n'appelle `setAlive(false)` que lorsque `remainingLives <= 0`, séparant ainsi la logique "perdre une vie" de "mourir définitivement". Le troisième, plus critique, consiste à remplacer tous les appels directs à `setAlive(false)` par `loseLife()` dans les gestionnaires de collision (`DefaultPlayerInteractionMap.java` et `PlayerCollisions.java`). Enfin, j'ajoute une méthode `resetLives()` pour réinitialiser les vies lors d'une nouvelle partie, et je mets à jour `ScorePanel.java` pour afficher visuellement le nombre de vies restantes.

**Phase 3 - Justification de l'ordre choisi** : Cette séquence n'est pas arbitraire mais répond à une logique de valeur et de risque. Commencer par l'ajout de l'attribut `remainingLives` (Valeur élevée, Risque minimal) permet de poser la base sans toucher au comportement existant. Créer ensuite `loseLife()` isole la nouvelle logique métier dans une méthode testable indépendamment. Ce n'est qu'une fois ces deux fondations posées que je modifie les points d'intégration critiques (les collisions), car à ce stade, la logique de remplacement est déjà validée. Les refactorings sur l'UI et la réinitialisation viennent en dernier car ce sont des améliorations cosmétiques ou utilitaires qui dépendent de tout le reste. Chaque étape est incrémentale, testable et réversible.

**Phase 4 - Validation et sécurisation** : Après chaque refactoring, j'applique une stratégie de validation systématique pour garantir la non-régression. Cela comprend la compilation du projet pour détecter immédiatement les erreurs de syntaxe, l'exécution des tests unitaires existants pour vérifier que le comportement des autres fonctionnalités n'est pas affecté, et des tests manuels ciblés pour valider que la nouvelle logique fonctionne comme attendu. Cette approche incrémentale permet de détecter rapidement les problèmes à chaque étape et, si nécessaire, de revenir en arrière sans compromettre l'ensemble du projet. Le résultat final est une fonctionnalité "Extra Lives" intégrée de manière sûre, progressive et maintenable.

---

## Question 2
Pourquoi considérez-vous ces refactorings comme importants pour votre objectif ?

**Réponse:**

Ces refactorings sont essentiels car ils transforment l'architecture actuelle rigide et binaire (vivant/mort) en un système flexible capable de gérer plusieurs vies tout en préservant la cohérence du code. L'ajout de l'attribut `remainingLives` dans `Player.java` est fondamental car il introduit le concept de "vies multiples" dans le modèle de données, ce qui est impossible avec le simple booléen `alive` actuel. La création de la méthode `loseLife()` est critique car elle encapsule la nouvelle logique métier en séparant clairement deux responsabilités distinctes : décrémenter le compteur de vies (comportement nouveau) et décider si le joueur est définitivement mort (comportement existant), ce qui respecte le principe de responsabilité unique et facilite les tests unitaires. Le remplacement de `setAlive(false)` par `loseLife()` dans les gestionnaires de collision (`DefaultPlayerInteractionMap.java` et `PlayerCollisions.java`) est le point d'intégration crucial qui fait réellement fonctionner la nouvelle mécanique : au lieu de mourir instantanément au premier contact avec un fantôme, le joueur perd maintenant une vie et peut continuer à jouer tant qu'il lui en reste. L'ajout de `resetLives()` assure que chaque nouvelle partie démarre avec 3 vies fraîches, évitant ainsi les bugs où un joueur commencerait une partie avec 0 vie. Enfin, la mise à jour de `ScorePanel.java` pour afficher le nombre de vies restantes est importante pour le feedback utilisateur : elle rend visible une information critique que le joueur doit connaître pour prendre des décisions stratégiques pendant le jeu. Sans ces refactorings, il serait impossible d'implémenter proprement la fonctionnalité "Extra Lives" - on serait tenté de bidouiller le code existant avec des conditions complexes dispersées partout, créant ainsi une dette technique importante et rendant le code fragile et difficile à maintenir.

---

## Question 3
Les outils précédents (CodeScene ou SonarQube) ont-ils identifié les cibles de refactoring que vous jugiez nécessaires pour atteindre cet objectif ?

**Réponse:**

Non, les outils CodeScene et SonarQube n'ont pas identifié les cibles de refactoring nécessaires pour atteindre l'objectif "Extra Lives", ce qui illustre parfaitement la différence entre le refactoring réactif (guidé par les outils) et le refactoring stratégique (guidé par un objectif fonctionnel). CodeScene a concentré son attention sur `Navigation.java`, `MapParser.java` et `CollisionInteractionMap.java` en raison de leur complexité cyclomatique élevée, de leurs méthodes avec trop de paramètres et de leurs conditions imbriquées, tandis que SonarQube a signalé des problèmes dans `Level.java` (utilisation excessive d'assert), `Ghost.java` (instanciation répétée de Random), et `ScorePanel.java` (problèmes de sérialisation). Or, pour implémenter la fonctionnalité "Extra Lives", les classes réellement critiques sont `Player.java` (qui doit stocker le nombre de vies), `DefaultPlayerInteractionMap.java` et `PlayerCollisions.java` (qui gèrent les collisions mortelles), et `ScorePanel.java` (pour l'affichage des vies) - seule cette dernière apparaît dans les rapports de SonarQube, mais pour des raisons totalement différentes (problèmes de sérialisation) et non pour son rôle dans la gestion des vies du joueur. La classe `Player.java`, pourtant au cœur de notre objectif, n'a été signalée par aucun des deux outils car elle ne présente aucun code smell ou problème de qualité : elle est simple, bien structurée, avec un code health score parfait selon CodeScene. Cela démontre que les outils d'analyse statique excellent pour détecter les problèmes de qualité technique (complexité, duplication, violations de bonnes pratiques), mais sont incapables d'anticiper les besoins fonctionnels futurs ou d'identifier les points d'extension nécessaires pour de nouvelles fonctionnalités. Les outils répondent à la question "Qu'est-ce qui ne va pas dans le code actuel ?" tandis que le refactoring stratégique répond à "Qu'est-ce qui doit changer pour supporter cette nouvelle fonctionnalité ?". Cette divergence confirme que le développeur doit comprendre l'architecture et les objectifs métier pour identifier les vraies cibles de refactoring, les outils ne servant que de complément pour améliorer la qualité globale.

---

## Question 4
Préférez-vous refactoriser uniquement pour améliorer la qualité du code ou refactoriser avec un objectif ? Pourquoi ?

**Réponse:**

Je préfère clairement le refactoring avec un objectif, car il permet de contrôler la profondeur et l'étendue des modifications tout en offrant une mesurabilité concrète du succès. Lorsqu'on refactorise uniquement pour la qualité, on risque de tomber dans un perfectionnisme sans fin : faut-il réduire toutes les méthodes complexes ? Faut-il éliminer tous les code smells, même mineurs ? Jusqu'où doit-on aller ? Sans objectif fonctionnel clair, il est difficile de savoir quand s'arrêter, et on peut facilement sur-ingénier le code ou gaspiller du temps sur des améliorations qui n'apportent pas de valeur métier immédiate. En revanche, le refactoring stratégique avec un objectif comme "ajouter la fonctionnalité Extra Lives" fournit un critère d'arrêt naturel : on refactorise uniquement ce qui est nécessaire pour atteindre cet objectif, ni plus ni moins. Cette approche est également beaucoup plus facilement mesurable et justifiable : on peut démontrer que le refactoring a permis d'implémenter la nouvelle fonctionnalité en X heures avec Y tests qui passent, ce qui est concret et quantifiable pour les parties prenantes. Cela dit, je reconnais que les deux approches sont complémentaires et non opposées : un code de haute qualité facilite grandement le refactoring avec objectif, car il est plus facile de modifier du code propre, bien structuré et testable que du code spaghetti rempli de code smells. Dans un monde idéal, on maintiendrait continuellement une bonne qualité de code (refactoring opportuniste au quotidien) tout en planifiant des refactorings stratégiques lorsque de nouveaux besoins fonctionnels émergent. L'expérience avec JPacman illustre parfaitement ce point : le code actuel est de très bonne qualité (Code Health Score de 9,69/10 selon CodeScene), ce qui rend notre refactoring stratégique pour "Extra Lives" beaucoup plus simple et moins risqué qu'il ne l'aurait été dans une base de code dégradée. En conclusion, je privilégie le refactoring avec objectif pour sa pragmatisme et sa valeur métier directe, mais je considère la qualité du code comme un investissement permanent qui rend tous les futurs refactorings stratégiques plus faciles, rapides et sûrs.

---
