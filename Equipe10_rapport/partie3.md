# Partie 3: Refactoring stratégique avec JPacman

## Question 1
Quelle est votre stratégie pour planifier ce refactoring ?

Pour planifier l'ajout de la fonctionnalité "Extra Lives" dans JPacman, j'adopte une approche méthodologique en quatre phases distinctes qui privilégie l'incrémentalité et la compréhension approfondie du système existant avant toute modification.

**Phase 1 - Analyse approfondie du système actuel** : Avant toute modification, je commence par une analyse complète de l'architecture existante. Cette analyse révèle des éléments clés : dans `Player.java`, la gestion de l'état du joueur repose sur un attribut booléen `alive` ; dans `MapParser.java`, les fantômes sont positionnés via `ghost.occupy(ghostSquare)` au moment de la création du niveau ; dans `Level.java`, la méthode `registerPlayer()` positionne le joueur après la création du niveau ; les collisions sont gérées par `PlayerCollisions.java` qui appelle directement `player.setAlive(false)` ; enfin, le niveau vérifie `isAnyPlayerAlive()` pour déterminer le game over. Cette compréhension est cruciale car elle identifie les points d'intégration et les dépendances qui devront être gérés lors du refactoring.

**Phase 2 - Planification des modifications structurelles** : La stratégie consiste à ajouter le système de vies en modifiant minimalement le code existant. D'abord, ajouter `remainingLives` dans `Player.java` avec sa logique de gestion (méthode `loseLife()` qui décrémente les vies et ne tue le joueur que si `remainingLives <= 0`). Ensuite, sauvegarder les positions initiales des joueurs et fantômes dans des Maps au moment de leur placement (`playerStartPositions` et `ghostStartPositions` dans `Level.java`). Puis, modifier les gestionnaires de collision pour appeler `loseLife()` au lieu de `setAlive(false)`. Enfin, implémenter un mécanisme de repositionnement qui remet tout le monde à sa position de départ quand le joueur perd une vie mais a encore des vies restantes.

**Phase 3 - Gestion du flux de jeu et synchronisation** : Cette phase critique concerne la coordination entre `Game` et `Level`. Lors d'une perte de vie, `Level.stop()` met le niveau en pause et appelle `updateObservers()` pour notifier l'UI. Dans `Game.move()`, après chaque mouvement, on vérifie si le niveau s'est arrêté et on appelle `Game.stop()` pour synchroniser l'état. Au redémarrage via `Game.start()` puis `Level.start()`, on vérifie si un joueur est mort avec des vies restantes, on repositionne tout le monde via `resetPositions()`, et on ressuscite le joueur avec `setAlive(true)`. Cette synchronisation Game-Level est essentielle pour que l'UI grise/active correctement les boutons Start/Stop.

**Phase 4 - Optimisation de l'expérience utilisateur** : Pour améliorer l'UX, plusieurs ajustements sont nécessaires : afficher le nombre de vies dans `ScorePanel.java` via un formatter "Lives: X | Score: Y" ; griser dynamiquement les boutons Start/Stop selon l'état du jeu dans `PacManUI.nextFrame()` pour éviter la confusion ; détecter la perte de vie pour tous les mouvements (joueur et fantômes) car un fantôme peut aussi percuter le joueur. Cette approche incrémentale et méthodique assure une intégration fluide de la fonctionnalité sans casser le code existant, avec une validation à chaque étape.

---

## Question 2
Pourquoi considérez-vous ces refactorings comme importants pour votre objectif ?

Ces refactorings sont essentiels car ils transforment l'architecture actuelle rigide en un système flexible capable de gérer plusieurs vies avec repositionnement automatique. L'ajout de l'attribut `remainingLives` dans `Player.java` est fondamental car il introduit le concept de vies multiples dans le modèle de données. La méthode `loseLife()` encapsule la logique métier en décrémentant les vies et ne tuant le joueur définitivement que si `remainingLives <= 0`, ce qui sépare clairement "perdre une vie" de "mourir définitivement".

La sauvegarde des positions initiales via `playerStartPositions` et `ghostStartPositions` dans `Level.java` est cruciale car elle permet le repositionnement. Ces Maps sont peuplées au moment du placement initial : les fantômes dans le constructeur de `Level` (car déjà positionnés par `MapParser`), et le joueur dans `registerPlayer()`. La méthode `resetPositions()` utilise ces Maps pour repositionner tous les personnages via `unit.occupy(square)`, restaurant l'état initial du plateau.

Le remplacement de `setAlive(false)` par `loseLife()` dans `PlayerCollisions.java` et `DefaultPlayerInteractionMap.java` est le point d'intégration critique. La détection de perte de vie dans `Level.move()` vérifie après chaque mouvement si un joueur est mort avec des vies restantes (`!player.isAlive() && player.getRemainingLives() > 0`), et arrête le niveau. Cette vérification se fait pour tous les mouvements (joueur et fantômes) car les deux peuvent causer une collision.

La synchronisation entre `Game` et `Level` est essentielle pour l'UX. Quand le niveau s'arrête, `Game.move()` détecte que `!getLevel().isInProgress()` et appelle `Game.stop()` pour synchroniser. Au redémarrage, `Level.start()` vérifie les joueurs morts avec vies restantes, appelle `resetPositions()`, puis `setAlive(true)`. La mise à jour de `ScorePanel.java` pour afficher "Lives: X | Score: Y" et le grisage dynamique des boutons Start/Stop dans `PacManUI.nextFrame()` complètent l'expérience utilisateur. Ces refactorings créent un système cohérent où perte de vie, pause, repositionnement et redémarrage fonctionnent ensemble de manière fluide.

---

## Question 3
Les outils précédents (CodeScene ou SonarQube) ont-ils identifié les cibles de refactoring que vous jugiez nécessaires pour atteindre cet objectif ?

**Réponse:**

Non, les outils CodeScene et SonarQube n'ont pas identifié les cibles de refactoring nécessaires pour atteindre l'objectif "Extra Lives", ce qui illustre parfaitement la différence entre le refactoring réactif (guidé par les outils) et le refactoring stratégique (guidé par un objectif fonctionnel). CodeScene a concentré son attention sur `Navigation.java`, `MapParser.java` et `CollisionInteractionMap.java` en raison de leur complexité cyclomatique élevée, de leurs méthodes avec trop de paramètres et de leurs conditions imbriquées, tandis que SonarQube a signalé des problèmes dans `Level.java` (utilisation excessive d'assert), `Ghost.java` (instanciation répétée de Random), et `ScorePanel.java` (problèmes de sérialisation). Or, pour implémenter la fonctionnalité "Extra Lives", les classes réellement critiques sont `Player.java` (qui doit stocker le nombre de vies), `DefaultPlayerInteractionMap.java` et `PlayerCollisions.java` (qui gèrent les collisions mortelles), et `ScorePanel.java` (pour l'affichage des vies) - seule cette dernière apparaît dans les rapports de SonarQube, mais pour des raisons totalement différentes (problèmes de sérialisation) et non pour son rôle dans la gestion des vies du joueur. La classe `Player.java`, pourtant au cœur de notre objectif, n'a été signalée par aucun des deux outils car elle ne présente aucun code smell ou problème de qualité : elle est simple, bien structurée, avec un code health score parfait selon CodeScene. Cela démontre que les outils d'analyse statique excellent pour détecter les problèmes de qualité technique (complexité, duplication, violations de bonnes pratiques), mais sont incapables d'anticiper les besoins fonctionnels futurs ou d'identifier les points d'extension nécessaires pour de nouvelles fonctionnalités. Les outils répondent à la question "Qu'est-ce qui ne va pas dans le code actuel ?" tandis que le refactoring stratégique répond à "Qu'est-ce qui doit changer pour supporter cette nouvelle fonctionnalité ?". Cette divergence confirme que le développeur doit comprendre l'architecture et les objectifs métier pour identifier les vraies cibles de refactoring, les outils ne servant que de complément pour améliorer la qualité globale.

---

## Question 4
Préférez-vous refactoriser uniquement pour améliorer la qualité du code ou refactoriser avec un objectif ? Pourquoi ?

**Réponse:**

Je préfère clairement le refactoring avec un objectif, car il permet de contrôler la profondeur et l'étendue des modifications tout en offrant une mesurabilité concrète du succès. Lorsqu'on refactorise uniquement pour la qualité, on risque de tomber dans un perfectionnisme sans fin : faut-il réduire toutes les méthodes complexes ? Faut-il éliminer tous les code smells, même mineurs ? Jusqu'où doit-on aller ? Sans objectif fonctionnel clair, il est difficile de savoir quand s'arrêter, et on peut facilement sur-ingénier le code ou gaspiller du temps sur des améliorations qui n'apportent pas de valeur métier immédiate. En revanche, le refactoring stratégique avec un objectif comme "ajouter la fonctionnalité Extra Lives" fournit un critère d'arrêt naturel : on refactorise uniquement ce qui est nécessaire pour atteindre cet objectif, ni plus ni moins. Cette approche est également beaucoup plus facilement mesurable et justifiable : on peut démontrer que le refactoring a permis d'implémenter la nouvelle fonctionnalité en X heures avec Y tests qui passent, ce qui est concret et quantifiable pour les parties prenantes. Cela dit, je reconnais que les deux approches sont complémentaires et non opposées : un code de haute qualité facilite grandement le refactoring avec objectif, car il est plus facile de modifier du code propre, bien structuré et testable que du code spaghetti rempli de code smells. Dans un monde idéal, on maintiendrait continuellement une bonne qualité de code (refactoring opportuniste au quotidien) tout en planifiant des refactorings stratégiques lorsque de nouveaux besoins fonctionnels émergent. L'expérience avec JPacman illustre parfaitement ce point : le code actuel est de très bonne qualité (Code Health Score de 9,69/10 selon CodeScene), ce qui rend notre refactoring stratégique pour "Extra Lives" beaucoup plus simple et moins risqué qu'il ne l'aurait été dans une base de code dégradée. En conclusion, je privilégie le refactoring avec objectif pour sa pragmatisme et sa valeur métier directe, mais je considère la qualité du code comme un investissement permanent qui rend tous les futurs refactorings stratégiques plus faciles, rapides et sûrs.

---
